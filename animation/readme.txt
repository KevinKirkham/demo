This is an animation project that I originally worked as part of the ITEC 324 class at Radford University. The goal was to display 1-3 shapes in a JPanel and have them animate across that panel, sliding in a linear fashion along some path. They were to wrap to the opposite side of the screen when they reached the edge of the screen. The three buttons at the top were originally meant to control the animation, though how the shapes are animated on the screen has since changed rendering the Show button useless.

The abbreviated description of how it works: 

Each Shape has an Animation object, which handles all things associated with the sprites in the shape's animation, and a Path object which does the math for calculating and maintaining the Shape's current position. The details of how each of these classes performs its job are written in the JavaDocs in each class. 

To instantiate a specific Shape, such as a Rocket, Bird, or UFO, the X-Y coordinates at which you want the Shape to be spawned must be supplied in the call to the constructor as well as the delta Y and delta X so that a linear path including the point that was specified in the call to the constructor can be made. A Shape's path data (the coordinate points that make up its path) is calculated on its creation - it is not calculated on the fly. The entirety of the Shape's path will be known just after it is created.

Wrapping

When a Shape first touches a border of the screen (a coordinate denoted by the spawn[] field in the Shape's Path object), a second Shape spawns on the opposite side of the screen, traveling at the same speed as the original Shape. I refer to this Shape as a "wrap companion" of the original Shape, as its purpose is to facilitate the illusion of a single Shape wrapping across the screen. This wrap companion is given the same Path object as that of the original Shape to avoid having to calculate the path again. The wrap companion enters the screen at the same speed as the original Shape is leaving the screen, and in proportion - if only 75% of the original Shape is still visible on the screen as it leaves the viewing window, then 25% of its wrap companion will be visible on the other side of the screen as it enters. Once a Shape is completely out of view (a coordinate denoted by the delete[] field in the Shape's Path object), the Shape is removed from the render list and removed from memory. 

Path Calculation

To create a Path, we must supply the constructor with an X-Y coordinate, a delta X and Delta Y, and the height and width of the Shape for whom the Path is to be created. The X-Y coordinate and delta X and delta Y are used to create the linear structure of the path. The formula of a line, y = mx + b, is the basis for calculating the points in the Shape's path. Given that y and x were supplied in the constructor, the slope m can be calculated by dividing delta Y by delta X, and from there b can be solved for. The value b maps to the point in the path at which it touches the point X = 0, which may be above the top of the screen or below the bottom of the screen. This is accounted for when determining which coordinate point should be the starting point and which coordinate point should be the end point. These start and end points (referred to as start[] and delete[] in the code) are then used as input for the approximatePath method, which accepts two points on a coordinate plane and calculates points between them that approximate a linear path such that no two points are ever more than one pixel away from one another. This allows for smooth and fluid movement along the path as there are no jumps or gaps.

Path Approximation

Approximation is necessary to ensure fluid movement because, mathematically, not every point on the path between the two supplied points lands on a coordinate point  that can be described with two integers - it is quite likely that the linear path between the start and end points contains a point that must be described with floating point numbers, such as (385.67, 219.81). The grid system used in Swing's JComponents doesn't allow an image to be rendered at such a point, and so each of its comprising coordinates must be approximated to whole numbers for display. The way I handled this was to round floating point values to their nearest whole number, so my example point (385.67, 219.81) would get approximated to (386, 220). See the JavaDoc comments above the approximatePath method in the Path class for a more detailed description of how the algorithm works. 
